#!.venv/bin/python3

import cv2
from tqdm import tqdm
import os
from pathlib import Path
from argparse import ArgumentParser
from transformers import AutoImageProcessor, DetrForObjectDetection
import torch
from torchvision.io import decode_image
from torchvision.utils import draw_bounding_boxes, save_image
from PIL import Image
import numpy as np
import subprocess

parser = ArgumentParser()
parser.add_argument("video", type=str, help="video file path to scan")
parser.add_argument("-frames", type=int, help="max number of frames to scan")
args = parser.parse_args()

image_processor = AutoImageProcessor.from_pretrained("facebook/detr-resnet-50")
model = DetrForObjectDetection.from_pretrained("facebook/detr-resnet-50")

video = args.video
vidreader = cv2.VideoCapture(video)

fps = vidreader.get(cv2.CAP_PROP_FPS)
total_frames = int(vidreader.get(cv2.CAP_PROP_FRAME_COUNT))
if args.frames:
    total_frames = min(total_frames, args.frames)
shape = (int(vidreader.get(cv2.CAP_PROP_FRAME_WIDTH)), int(vidreader.get(cv2.CAP_PROP_FRAME_HEIGHT)))
intermediate_file = "__inter__.mp4"

vidwriter = cv2.VideoWriter(intermediate_file, cv2.VideoWriter_fourcc(*"mp4v"), fps, shape)

for i in tqdm(range(total_frames), desc="Scanning video for objects and writing to new video"):
    ret, frame = vidreader.read()
    frame = torch.from_numpy(frame.transpose(2, 0, 1))

    inputs = image_processor(images=frame, return_tensors="pt")
    outputs = model(**inputs)

    target_sizes = torch.tensor([shape[::-1]])
    results = image_processor.post_process_object_detection(outputs, threshold=0.9, target_sizes=target_sizes)[
        0
    ]

    frame = (255.0 * (frame - frame.min()) / (frame.max() - frame.min())).to(torch.uint8)
    frame = frame[:3, ...]
    pred_boxes = results["boxes"].long()
    labels = [f"{model.config.id2label[label.item()]}: {score} " for label, score in zip(results["labels"], results["scores"])]
    output_image = draw_bounding_boxes(frame, pred_boxes, labels, colors="red")

    vidwriter.write(output_image.cpu().numpy().transpose(1, 2, 0))
vidwriter.release()

if os.path.exists("trackedmedia.mp4"):
    os.remove("trackedmedia.mp4")
# the media is corrupt in curtain file editors for whatever reason, running it through ffmpeg fixes this
subprocess.run(["ffmpeg", "-i", intermediate_file, "trackedmedia.mp4"])
os.remove("__inter__.mp4")